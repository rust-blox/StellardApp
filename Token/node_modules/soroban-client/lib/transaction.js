"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assembleTransaction = assembleTransaction;
var _stellarBase = require("stellar-base");
function assembleTransaction(raw, networkPassphrase, simulation) {
  var _invokeOp$auth, _simulation$results$, _simulation$results$2;
  if ("innerTransaction" in raw) {
    return assembleTransaction(raw.innerTransaction, networkPassphrase, simulation);
  }
  if (!isSorobanTransaction(raw)) {
    throw new TypeError("unsupported transaction: must contain exactly one " + "invokeHostFunction, bumpFootprintExpiration, or restoreFootprint " + "operation");
  }
  if (simulation.results.length !== 1) {
    throw new Error("simulation results invalid: ".concat(simulation.results));
  }
  var source = new _stellarBase.Account(raw.source, "".concat(parseInt(raw.sequence, 10) - 1));
  var classicFeeNum = parseInt(raw.fee, 10) || 0;
  var minResourceFeeNum = parseInt(simulation.minResourceFee, 10) || 0;
  var txnBuilder = new _stellarBase.TransactionBuilder(source, {
    fee: (classicFeeNum + minResourceFeeNum).toString(),
    memo: raw.memo,
    networkPassphrase: networkPassphrase,
    timebounds: raw.timeBounds,
    ledgerbounds: raw.ledgerBounds,
    minAccountSequence: raw.minAccountSequence,
    minAccountSequenceAge: raw.minAccountSequenceAge,
    minAccountSequenceLedgerGap: raw.minAccountSequenceLedgerGap,
    extraSigners: raw.extraSigners
  });
  switch (raw.operations[0].type) {
    case "invokeHostFunction":
      var invokeOp = raw.operations[0];
      txnBuilder.addOperation(_stellarBase.Operation.invokeHostFunction({
        source: invokeOp.source,
        func: invokeOp.func,
        auth: ((_invokeOp$auth = invokeOp.auth) !== null && _invokeOp$auth !== void 0 ? _invokeOp$auth : []).concat((_simulation$results$ = (_simulation$results$2 = simulation.results[0].auth) === null || _simulation$results$2 === void 0 ? void 0 : _simulation$results$2.map(function (a) {
          return _stellarBase.xdr.SorobanAuthorizationEntry.fromXDR(a, "base64");
        })) !== null && _simulation$results$ !== void 0 ? _simulation$results$ : [])
      }));
      break;
    case "bumpFootprintExpiration":
      txnBuilder.addOperation(_stellarBase.Operation.bumpFootprintExpiration(raw.operations[0]));
      break;
    case "restoreFootprint":
      txnBuilder.addOperation(_stellarBase.Operation.restoreFootprint(raw.operations[0]));
      break;
  }
  var sorobanTxData = _stellarBase.xdr.SorobanTransactionData.fromXDR(simulation.transactionData, "base64");
  txnBuilder.setSorobanData(sorobanTxData);
  return txnBuilder.build();
}
function isSorobanTransaction(tx) {
  if (tx.operations.length !== 1) {
    return false;
  }
  switch (tx.operations[0].type) {
    case "invokeHostFunction":
    case "bumpFootprintExpiration":
    case "restoreFootprint":
      return true;
    default:
      return false;
  }
}