"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Contract = void 0;
var _address = require("./address");
var _operation = require("./operation");
var _xdr = _interopRequireDefault(require("./xdr"));
var _strkey = require("./strkey");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
/**
 * Create a new Contract object.
 *
 * `Contract` represents a single contract in the Stellar network, embodying the
 * interface of the contract. See
 * [Contracts](https://soroban.stellar.org/docs/learn/interacting-with-contracts)
 * for more information about how contracts work in Stellar.
 *
 * @constructor
 *
 * @param {string} contractId - ID of the contract (ex.
 *     `CA3D5KRYM6CB7OWQ6TWYRR3Z4T7GNZLKERYNZGGA5SOAOPIFY6YQGAXE`, or as a
 *     32-byte hex string
 *     `000000000000000000000000000000000000000000000000000000000000000001`).
 */
// TODO: Support contract deployment, maybe?
var Contract = /*#__PURE__*/function () {
  function Contract(contractId) {
    _classCallCheck(this, Contract);
    try {
      // First, try it as a strkey
      this._id = _strkey.StrKey.decodeContract(contractId);
    } catch (_) {
      // If that fails, try it as a hex string
      // TODO: Add methods based on the contractSpec (or do that elsewhere?)
      var b = Buffer.from(contractId, 'hex');
      if (b.length !== 32) {
        throw new Error('Invalid contract ID');
      }
      this._id = b;
    }
  }

  /**
   * Returns Stellar contract ID as a strkey, or hex string, ex.
   * `000000000000000000000000000000000000000000000000000000000000000001`.
   * @param {'hex'|'strkey'} format - format of output, defaults to 'strkey'
   * @returns {string}
   */
  _createClass(Contract, [{
    key: "contractId",
    value: function contractId() {
      var format = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'strkey';
      switch (format) {
        case 'strkey':
          return _strkey.StrKey.encodeContract(this._id);
        case 'hex':
          return this._id.toString('hex');
        default:
          throw new Error("Invalid format: ".concat(format));
      }
    }

    /**
     * Returns the address of this contract as an Address type.
     * @returns {Address}
     */
  }, {
    key: "address",
    value: function address() {
      return _address.Address.contract(this._id);
    }

    /**
     * Returns an operation that will invoke this contract call.
     *
     * @param {string} method - name of the method to call
     * @param {...xdr.ScVal} params - arguments to pass to the function call
     * @returns {xdr.Operation} Build a InvokeHostFunctionOp operation to call the
     * contract.
     */
  }, {
    key: "call",
    value: function call(method) {
      for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }
      return _operation.Operation.invokeHostFunction({
        func: _xdr["default"].HostFunction.hostFunctionTypeInvokeContract([this.address().toScVal(), _xdr["default"].ScVal.scvSymbol(method)].concat(params)),
        auth: []
      });
    }

    /**
     * Returns the read-only footprint entry necessary for any invocations to this
     * contract, for convenience when adding it to your transaction's overall
     * footprint.
     *
     * @returns {xdr.LedgerKey} the contract's executable data ledger key
     */
  }, {
    key: "getFootprint",
    value: function getFootprint() {
      return _xdr["default"].LedgerKey.contractData(new _xdr["default"].LedgerKeyContractData({
        contract: this.address().toScAddress(),
        key: _xdr["default"].ScVal.scvLedgerKeyContractInstance(),
        durability: _xdr["default"].ContractDataDurability.persistent(),
        bodyType: _xdr["default"].ContractEntryBodyType.dataEntry()
      }));
    }
  }]);
  return Contract;
}();
exports.Contract = Contract;